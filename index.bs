<pre class='metadata'>
Title: Identity Federation Management API
Shortname: webid
Level: 1
Status: CG-DRAFT
Group: WICG
ED: http://wicg.github.io/WebID
Repository: WICG/WebID
Editor: Sam Goto, Google Inc. https://google.com, goto@google.com
Markup Shorthands: markdown yes, css no, biblio yes
Default Biblio Display: inline
Text Macro: FALSE <code>false</code>
Text Macro: TRUE <code>true</code>
Text Macro: RP Relying Party
Text Macro: IDP Identity Provider
Abstract: This specification defines a set of [=high-level API=]s that enables users to continue to use [=Identity Provider=]s to authenticate to [=Relying Party=]s without incurring into [=unsactioned tracking=] on the Web. It accomplishes that by exposing the explicit user controls needed to manage the lifecycle of their federated accounts.
Test Suite: https://github.com/web-platform-tests/wpt/blob/master/credential-management/webid.https.html
</pre>

<pre class=anchors>
spec: ecma262; urlPrefix: https://tc39.github.io/ecma262/
    type: dfn
        text: time values; url: sec-time-values-and-time-range
        text: promise; url: sec-promise-objects

spec: credential-management-1; urlPrefix: https://w3c.github.io/webappsec-credential-management/
    type: dictionary
        text: CredentialRequestOptions; url: dictdef-credentialrequestoptions
    for: Credential
        type: method
            text: [[CollectFromCredentialStore]](origin, options, sameOriginWithAncestors)
            text: [[Create]](origin, options, sameOriginWithAncestors)
            text: [[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)
            text: [[Store]](credential, sameOriginWithAncestors)
    type: dfn
        text: signal
        text: same-origin with its ancestors; url: same-origin-with-its-ancestors
</pre>

<pre class=link-defaults>
spec:infra; type:dfn; text:list
spec:html; type:dfn; for:environment settings object; text:global object
spec:webidl; type:dfn; text:resolve
</pre>

<style>
dl.domintro dt {
    font-family: Menlo, Consolas, "DejaVu Sans Mono", Monaco, monospace;

    padding-top: 0.5em;
    padding-bottom: 1em;
}
dl.domintro dt a {
    color: inherit; border-bottom-style: none;
}
dl.domintro dt code {
    font-size: inherit;
}
</style>

<!-- ============================================================ -->
# Introduction # {#intro}
<!-- ============================================================ -->

*This section is non-normative.*

Over the last decade, identity federation has unquestionably played a central role in raising the bar for authentication on the web, in terms of ease-of-use (e.g. passwordless single sign-on), security (e.g. improved resistance to phishing and credential stuffing attacks) and trustworthiness compared to its preceding pattern: per-site usernames and passwords.

The standards that define how identity federation works today on the Web were built independently of the Web Platform (namely, [[SAML]], [[OpenID]] and [[OAuth]]), and their designers had to (rightfully so) work around its limitations rather than extend them.

Because of that, existing user authentication flows were designed on top of general-purpose web platform capabilities such as top-level navigations/redirects with parameters, window popups, iframes and cookies.

However, because these general purpose primitives can be used for an open ended number of use cases (again, notably, by design), browsers have to apply policies that capture the lowest common denominator of abuse, at best applying cumbersome permissions (e.g. popup blockers) and at worst entirely blocking them (e.g. blocking third party cookies).

Over the years, as these [=low-level API=]s get abused, browsers intervene and federation adjusts itself. For example, popup blockers became common and federation had to adjust itself to work in a world where popups blockers were widely deployed.

The challenge is that some of these low level primitives are getting increasingly abused to allow users on the web to be tracked. So, as a result, browsers are applying stricter and stricter policies around them.

This specification defines a set of [=high-level API=]s that serve as a foundation where identity federation on Web can thrive without incurring into [=unsactioned tracking=].

<!-- ============================================================ -->
# Use Cases # {#use-cases}
<!-- ============================================================ -->

The below use case scenarios illustrate some basic supported flows. Additional scenarios, including sample code, are given later in the [[Identity-Use-Cases-in-Browser-Catalog]].

<!-- ============================================================ -->
## Sign-up ## {#use-cases-sign-up}
<!-- ============================================================ -->

A Sign-up occurs when the user is registering a new account at the [=Relying Party=] using their [=Identity Provider=].

For example:

* A user navigates to a [=Relying Party=] in a browser and decides to create an account.
* The [=Relying Party=] supports multiple [=Identity Provider=] as an authentication mechanism.
* A user selects their favorite [=Identity Provider=] to sign-up with.
* The [=Identity Provider=] prompts, "Do you want to create an account with the [=Relying Party=]?"
* The user agrees.
* The [=Relying Party=] shows the message "Registration complete."
* An [=account=] in created in the [=Relying Party=] and a [=session=] initialized.

<!-- ============================================================ -->
## Sign-in ## {#use-cases-sign-in}
<!-- ============================================================ -->

After a user navigates to a [=Relying Party=] in a browser and decides to create an account by going through their [[#use-cases-sign-up]] flow, there are two ways a user logs into their [=account=] once their [=session=] expires:

<!-- ============================================================ -->
### Auto Sign-in ### {#use-cases-auto-sign-in}
<!-- ============================================================ -->

Auto Sign-in occurs when the [=Identity Provider=] has already gathered enough permission from the user to share their identity that it doesn't block on gathering further permission and automatically signs the user in.

For example:

* Using another device (e.g. their laptop):
    * The user goes to the [=Relying Party=].
    * The user selects their favorite [=Identity Provider=] to sign-in.
    * The [=Identity Provider=] remembers and proves that the user already has an [=account=] with the [=Relying Party=].
    * The [=Relying Party=] creates a new [=session=] for the user's existing [=account=].

<!-- ============================================================ -->
### Explicit Sign-in ### {#use-cases-explicit-sign-in}
<!-- ============================================================ -->

An explicit sign-in occurs when the [=Identity Provider=] believes it is necessary to gather an explicit permission from the user to sign into a [=Relying Party=], typically after the user goes through a [[#use-cases-sign-out]] flow.

For example:

* The user decides to [[#use-cases-sign-out]] of the [=Relying Party=]

A few months later:

* The user navigates to the [=Relying Party=]
* The user selects their favorite [=Identity Provider=] to sign-in again.
* The [=Identity Provider=] knows that:
    * the user already has an account with the [=Relying Party=].
    * the user has logged out of the [=Relying Party=].
* The [=Identity Provider=] prompts, "Do you want to sign-in with the [=Relying Party=]?"
* The user agrees.
* The [=Relying Party=] creates a new [=session=] for the user's existing [=account=].

<!-- ============================================================ -->
## Sign-out ## {#use-cases-sign-out}
<!-- ============================================================ -->

After a user navigates to a [=Relying Party=] in a browser and decides to create an [=account=] by going through their [[#use-cases-sign-up]] flow, there are two ways a user can clear their [=session=]s:

<!-- ============================================================ -->
### RP Sign-out ### {#use-cases-rp-sign-out}
<!-- ============================================================ -->

* On a shared computer:
    * The user decides to close their session and logs out of the [=Relying Party=].
    * The user is now logged out of the [=Relying Party=].
    * Upon return to the [=Relying Party=], the user expects to go through an [[#use-cases-explicit-sign-in]].

<!-- ============================================================ -->
### IDP Sign-out ### {#use-cases-idp-sign-out}
<!-- ============================================================ -->

* On a shared computer:
    * The user decides to close their [=session=] and logs out of the [=Relying Party=].
    * The [=Relying Party=] lets the [=Identity Provider=] know that the user wants to logout.
    * The [=Identity Provider=] logs the user out of all of the [=Relying Party=]s and itself.
    * Upon return to the [=Relying Party=], the goes through an [[#use-cases-explicit-sign-in]].

<!-- ============================================================ -->
## Revocation ## {#use-cases-revocation}
<!-- ============================================================ -->

After a user navigates to a [=Relying Party=] in a browser and decides to create an account by going through their [[#use-cases-sign-up]] flow, there are two ways a user can cancel their account:

<!-- ============================================================ -->
### IDP Revocation ### {#use-cases-idp-revocation}
<!-- ============================================================ -->

* On the [=Identity Provider=]:
    * The user decides to cancel their account.
    * The user goes to their [=Identity Provider=] and revokes access to the [=Relying Party=].
    * Upon return to the [=Relying Party=], the user expects to go through a [[#use-cases-sign-up]].  

<!-- ============================================================ -->
### RP Revocation ### {#use-cases-rp-revocation}
<!-- ============================================================ -->

* On the [=Relying Party=]:
    * The user decides to cancel their account.
    * The user navigates to the [=Relying Party=] and cancels their account, also letting the [=Identity Provider=] know.
    * Upon return to the [=Relying Party=], the user expects to go through a [[#sign-up]].  

<!-- ============================================================ -->
## Access ## {#Access}
<!-- ============================================================ -->

* A user navigates to a [=Relying Party=] in a browser and decides to create an [=account=].
* The [=Relying Party=] supports multiple [=Identity Provider=] which provide access to the user's Calendar.
* A user selects their favorite [=Identity Provider=] to sign-up with.
* The [=Identity Provider=] prompts, "Do you want to give access to your Calendar to the [=Relying Party=]?"
* The user agrees.
* The [=Relying Party=] shows message, "Registration complete.", creates a [=session=] for the user and
* Shows the user their calendar entries provided by the [=Identity Provider=].

<!-- ============================================================ -->
# Examples # {#examples}
<!-- ============================================================ -->

This specification extends the {{FederatedCredential}} type and internal algorithms to allow the exchange
of identity between [=IDP=]s and [=RP=]s. When it succeeds, it returns to the [=RP=] a signed [=id token=]
which the [=RP=] can use to authenticate the user.

<div class=example>
```js
async function login(signal) {
  const {idToken} = await navigator.credentials.get({
    // controls whether auto sign-in is enabled or not
    mediation: "optional",
    // controls abortions of the account chooser
    signal: signal

    // controls which identity providers to use
    federated: {
      // controls which UX mode to use
      mode: "mediated",
      // controls whether the account chooser is modal or not
      providers: [{
        url: "https://idp.example",
        // the pre-registered client id  
        clientId: "123",
        nonce: "456"
      }],
    }
  });

  return idToken;
}
```
</div>

<!-- ============================================================ -->
# Terminology # {#terminology}
<!-- ============================================================ -->

: <dfn>Relying Party</dfn>
: <dfn>RP</dfn>
: <dfn>Website</dfn>
:: TODO(goto): find existing definitions.

: <dfn>Identity Provider</dfn>
: <dfn>IDP</dfn>
:: TODO(goto): find existing definition.

: <dfn>session</dfn>
:: TODO(goto): find existing definition.

: <dfn>account</dfn>
:: TODO(goto): find existing definition.

: <dfn>id token</dfn>
:: TODO(goto): find existing definition.

: <df>unsactioned tracking</dfn>
:: The type of tracking on the web described in [[Unsanctioned-Web-Tracking]].

: <dfn>high-level API</dfn>
:: A use case specific API, as opposed to a [=low-level API=].

: <dfn>low-level API</dfn>
:: A general purpose API, as opposed to a [=high-level API=].

: <dfn>registered</dfn>
:: TODO(goto): find existing definition.

: <dfn>unregistered</dfn>
:: TODO(goto): find existing definition.

: <dfn>logged in</dfn>
:: TODO(goto): find existing definition.

: <dfn>logged out</dfn>
:: TODO(goto): find existing definition.

: <dfn>out-of-band</dfn>
:: Outside of the user agent's context.

<!-- ============================================================ -->
# High Level Design # {#lifecycle}
<!-- ============================================================ -->

At a high level, the Identity Federation Management API works by the intermediation of cooperating [=IDP=]s and [=RP=]s.

The [[#idp-api]] and the [[#rp-api]] defines a set of HTTP APIs that cooperating [=IDP=]s and [=IDP=]s exposes as well as the entry points in the [[#API]] that they can use.

<img src="static/mock43.svg">

The user agent intermediates in such a matter that makes it impractical for the API to be used for tracking purposes, while preserving the functionality of identity federation.

This document defines the APIs in the following order:

1. The [[#idp-api]]
1. The [[#rp-api]] 
1. The [[#API]] 

<!-- ============================================================ -->
# The Identity Provider API # {#idp-api}
<!-- ============================================================ -->

The [=IDP=] proactively and cooperatively exposes itself as a comformant agent by exposing a series of HTTP endpoints:

1. A [[#well-known]] endpoint in a well-known location that points to	   ,
1. An [[#accounts_endpoint]] endpoint
1. A [[#client_id_metadata_endpoint]] endpoint
1. An [[#idtoken_endpoint]] endpoint

<!-- ============================================================ -->
## Discovery ## {#well-known}
<!-- ============================================================ -->

The well-known discovery endpoint is an endpoint located at the [=IDP=]'s `.well-known/webid` and serves as a discovery device to other endpoints provided by the [=IDP=]. 

The well-known discovery endpoint is fetched (a) **without** cookies and (b) **with** a special [[#Sec-WebID-CSR]] header.

For example:

<div class=example>
```http
GET /.well-known/webid HTTPS/1.1
Host: idp.example
Content-Type: application/json
Sec-WebID-CSRF: random_value
```
</div>

The file is parsed expecting the following properties:

<dl dfn-type="argument" dfn-for="WellKnown">
    :   <dfn>accounts_endpoint</dfn>
    ::  A URL that points to an HTTP API that complies with the [[#accounts_endpoint]] API.
    :   <dfn>client_id_metadata_endpoint</dfn>
    ::  A URL that points to an HTTP API that complies with the [[#client_id_metadata_endpoint]] API.
    :   <dfn>idtoken_endpoint</dfn>
    ::  A URL that points to an HTTP API that complies with the [[#idtoken_endpoint]] API.
</dl>

For example:

<div class=example>
```json
{
  "accounts_endpoint": "/accounts.php",
  "client_id_metadata_endpoint": "/metadata.php",
  "idtoken_endpoint": "/idtokens.php",
}
```
</div>

<!-- ============================================================ -->
## Accounts List ## {#accounts_endpoint}
<!-- ============================================================ -->

The accounts list endpoint provides the list of accounts the user has at the [=IDP=].

The accounts list endpoint is fetched (a) **with** any cookies and (b) **with** a special [[#Sec-WebID-CSR]] header.

For example:

<div class=example>
```http
GET /accounts_list.php HTTPS/1.1
Host: idp.example
Content-Type: application/json
Cookie: 0x23223
Sec-WebID-CSRF: random_value
```
</div>

The response is expected to have the following properties:

<dl dfn-type="argument" dfn-for="accounts_endpoint_response">
    :   <dfn>accounts</dfn>
    ::  A list of [=Account JSON=].
</dl>

Every <dfn>Account JSON</dfn> is expected to have the following properties:

<dl dfn-type="argument" dfn-for="accounts_endpoint_response_accounts">
    :   <dfn>account_id</dfn>
    ::  An account identifier.
    :   <dfn>name</dfn>
    ::  The user's full name.
    :   <dfn>given_name</dfn>
    ::  The user's given name.
    :   <dfn>email</dfn>
    ::  The user's email address.
    :   <dfn>picture</dfn>
    :: The user's profile picture.
</dl>

For example:

<div class=example>
```json
{
 "accounts": [
  { 
   "account_id": "1234", 
   "given_name": "John",  
   "name": "John Doe",
   "email": "john_doe@idp.example", 
   "picture": "https://idp.example/profile/123",

  },
  {
   "account_id": "5678", 
   "given_name": "Johnny", 
   "name": "Johnny",
   "email": "johnny@idp.example",
   "picture": "https://idp.example/profile/456"
  }
 ]
}
```
</div>

<!-- ============================================================ -->
## Client Metadata ## {#client_id_metadata_endpoint}
<!-- ============================================================ -->

The client metadata endpoint provides metadata about [=RP=]s.

The client medata endpoint is fetched (a) **without** cookies and (b) **with** a special [[#Sec-WebID-CSR]] header.

For example:

<div class=example>
```http
GET /client_medata.php HTTPS/1.1
Host: idp.example
Content-Type: application/json
Sec-WebID-CSRF: random_value
```
</div>

The file is parsed expecting the following properties:

<dl dfn-type="argument" dfn-for="client_id_metadata_endpont_response">
    :   <dfn>privacy_policy_url</dfn>
    ::  A link to the [=RP=]'s privacy policy.
    :   <dfn>terms_of_service_url</dfn>
    ::  A link to the [=RP=]'s terms of service.
</dl>

For example:

<div class=example>
```json
{
  "privacy_policy_url": "/privacy.html",
  "terms_of_service_url": "/terms.html",
}
```
</div>

<!-- ============================================================ -->
## ID Token ## {#idtoken_endpoint}
<!-- ============================================================ -->

The ID Token endpoint is responsible for minting a new idtoken for the user.

The ID Token endpoint is fetched (a) as a **POST** request, (b)  **with** cookies and (c) **with** a special [[#Sec-WebID-CSR]] header.

It will also contain the following parameters passed as a JSON object:

<dl dfn-type="argument" dfn-for="idtoken_endpoint_request">
    :   <dfn>account_id</dfn>
    :: The account identifier that was selected.
    :   <dfn>request</dfn>
    :: The [=RP request=]
</dl>

The <dfn>RP request</dfn> has the following properties:

<dl dfn-type="argument" dfn-for="idtoken_endpoint_request_request">
    :   <dfn>client_id</dfn>
    :: The [=RP=]'s client it
    :   <dfn>nonce</dfn>
    :: A random number of the choice of the [=RP=]
</dl>

For example:

<div class=example>
```http
POST /webid_token_endpoint HTTPS/1.1
Host: idp.example
Referrer: rp.example
Content-Type: application/json
Cookie: 0x23223
Sec-WebID-CSRF: random_value
{
  "account_id": "123",
  "request": {
    "client_id": "client1234",
    "nonce": "Ct60bD" 
  }
}
```
</div>

The response is parsed as a JSON file expecting the following properties:

<dl dfn-type="argument" dfn-for="idtoken_endpoint_response">
    :   <dfn>id_token</dfn>
    ::  The resulting [=id token=].
</dl>

For example:

<div class=example>
```json
{
  "id_token" : "eyJC...J9.eyJzdWTE2...MjM5MDIyfQ.SflV_adQssw....5c"
}
```
</div>

<!-- ============================================================ -->
## Revocation ## {#revocation_endpoint}
<!-- ============================================================ -->

Note: support revocation.

<!-- ============================================================ -->
## <code><dfn data-export="">`Sec-WebID-CSR`</dfn></code> ## {#Sec-WebID-CSR}
<!-- ============================================================ -->

<!-- ============================================================ -->
# The Relying Party API # {#rp-api}
<!-- ============================================================ -->

[=RP=]'s expose a [[#logout_endpoint]] to facilitate with [[#use-cases-idp-sign-out]].

<!-- ============================================================ -->
## Logout ## {#logout_endpoint}
<!-- ============================================================ -->

When [=IDP=]s call the [[#idp-sign-out]] API, every [=RP=] gets a
chance to log the user out (e.g. clear cookies, clear local storage)
via the logout endpoint.

The logout endpoint is an endpoint that is registered with the [=IDP=]
[=out-of-band=].

The logout endpoint is called (a) with a **GET** and (b) with the [=RP=]'s cookies.

<!-- ============================================================ -->
# The Browser API # {#API}
<!-- ============================================================ -->

The Browser API exposes APIs to [=RP=]s and [=IDP=]s to call and intermediates the exchange of the user's identity.

For [=RP=]s, it allows them to:

1. The [[#sign-in]] allows [=RP=]'s users to [[#use-cases-sign-up]] and [[#use-cases-sign-up]]
1. The [[#revocation]] allows [=RP=]'s users to go through [[#use-cases-rp-revocation]] of their accounts
1. The [[#rp-sign-out]] API allows [=RP=]s to [[#use-cases-rp-sign-out]] of their accounts.

For [=IDP=]s, it allows them to:

1. The [[#idp-sign-out]] API allows [=IDP=]s to [[#use-cases-idp-sign-out]] of their accounts.

The Browser API manages the lifecycle of the user's accounts and sessions with an internal [[#state-machine]].

<!-- ============================================================ -->
## The State Machine ## {#state-machine}
<!-- ============================================================ -->

Internally, the account management and session management APIs allows the user to explicitly move through the different stages of their accounts. At each stage, the state machine manages the [=RP=]'s and the [=IDP=]'s access to the appropriate browser capabilities.

<img src="static/mock42.svg">

<dl dfn-type="argument" dfn-for="StateMachine">
    :   <dfn>Account State</dfn>
    ::  Keeps track of whether the user has an account or not. Can be [=registered=] or (by default) [=unregistered=].
    :   <dfn>Session State</dfn>
    ::  Keeps track of whether the user has an open or closed session. Can be [=logged in=] or (by default) [=logged out=].
</dl>

<!-- ============================================================ -->
## The Sign-in API ## {#sign-in}
<!-- ============================================================ -->

The Sign-up and Sign-in APIs are APIs used by the [=Relying Party=]s to ask the browser to intermediate the relationship with the [=Identity Provider=] and the provisioning of an [=id token=].

The [=Relying Party=] makes no delineation between Sign-up and Sign-in, but rather call the same API indistinguishably. The most important parameter to the API call is the set of [=Identity Provider=]s that the [=Relying Party=] supports and has pre-registered with (i.e. it has a `clientId`).

Additionally, the [=Relying Party=] can control a variety of UX knobs. For example, whether to allow an [[#use-cases-auto-sign-in]] flow and an AbortSignal in case it needs to abort the flow.

If all goes well, the [=Relying Party=] receives back an [=id token=] in the form of a signed [[JWT]] which it can use to authenticate the user.

<div class=example>
```js
async function login(signal) {
  const {idToken} = await navigator.credentials.get({
    // controls whether auto sign-in is enabled or not
    mediation: "optional",
    // controls abortions of the account chooser
    signal: signal

    // controls which identity providers to use
    federated: {
      // controls which UX mode to use
      mode: "mediated",
      // controls whether the account chooser is modal or not
      providers: [{
        url: "https://idp.example",
        // the pre-registered client id  
        clientId: "123",
        nonce: "456"
      }],
    }
  });

  return idToken;
}
```
</div>

To accomplish that, this specification does three things:

1. It extends {{FederatedCredential}} with more fields.
1. It redefines {{FederatedCredential}}'s <code><dfn for="FederatedCredential" method>\[[DiscoverFromExternalSource]]()</dfn></code>.
1. It extends {{FederatedCredentialRequestOptions}} with more options.

First, this specification extends the {{FederatedCredential}} type adding two more fields:

<xmp class=idl>
enum FederatedCredentialApprovedBy {
  "auto",
  "user"
};

[Exposed=Window, SecureContext]
partial interface FederatedCredential : Credential {
  readonly attribute USVString idToken;
  readonly attribute FederatedCredentialApprover approvedBy;
};
</xmp>

<dl dfn-type="attribute" dfn-for="FederatedCredential">
    :   {{idToken}}
    ::  The [=id token=].

    :   {{approvedBy}}
    ::  When used in conjunction with {{CredentialRequestOptions/mediation}}, it indicates whether the credential was provided via a [[#use-cases-auto-sign-in]] or an [[#use-cases-explicit-sign-in]].
</dl>

Second, it extends the {{FederatedCredentialRequestOptions}} by adding a list of {{FederatedIdentityProvider}}s:

<xmp class=idl>
partial dictionary FederatedCredentialRequestOptions {
  sequence<(DOMString or FederatedIdentityProvider)> providers;
};

dictionary FederatedIdentityProvider {
  required USVString url;
  USVString clientId;
  USVString nonce;
};
</xmp>

And finally, this specification overrides the {{FederatedCredential}}'s <code><dfn for="FederatedCredential" method>\[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)</dfn></code> Method.

This algorithm runs in parallel inside the [[CM#algorithm-request]] to request credentials and returns a set of {{FederatedCredential}} objects from a remote [=Identity Provider=].

This [=internal method=] accepts three arguments:

<dl dfn-type="argument" dfn-for="FederatedCredential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)">

    :   <dfn>origin</dfn>
    ::  This argument is the [=relevant settings object=]'s [=environment settings object/origin=], as determined by the
        calling {{CredentialsContainer/get()}} implementation, i.e., {{CredentialsContainer}}'s <a abstract-op>Request a `Credential`</a> abstract operation.

    :   <dfn>options</dfn>
    ::  This argument is a {{CredentialRequestOptions}} object whose
        <code>|options|.{{CredentialRequestOptions/federated}}</code> member contains a {{FederatedCredentialRequestOptions}}
        object specifying the exchange options.

    :   <dfn>sameOriginWithAncestors</dfn>
    ::  This argument is a Boolean value which is [TRUE] if and only if the caller's [=environment settings object=] is
        [=same-origin with its ancestors=]. It is [FALSE] if caller is cross-origin.
</dl>

When this method is invoked, the user agent MUST execute the following algorithm:

    1.  If <var ignore>sameOriginWithAncestors</var> is `false`, return a "{{NotAllowedError}}" {{DOMException}}.

        Note: This restriction aims to address the concern raised in [[Security-Origin-Confusion]].

    1.  Assert: |options|["{{CredentialRequestOptions/federated}}"]["{{FederatedCredentialRequestOptions/providers}}"] [=map/exists=].

    1.  Assert: |options|["{{CredentialRequestOptions/federated}}"]["{{FederatedCredentialRequestOptions/providers}}"] [=list/size=] is 1.

        Note: At some point we would like to support choosing accounts from multiple [=Identity Provider=]s.

    1. Let |provider| be |options|["{{CredentialRequestOptions/federated}}"]["{{FederatedCredentialRequestOptions/providers}}"][0].

    1. Assert: |provider|["{{FederatedIdentityProvider/url}}"] [=map/exists=].

    1. Assert: |provider|["{{FederatedIdentityProvider/clientId}}"] [=map/exists=].

    1. Assert: |provider|["{{FederatedIdentityProvider/nonce}}"] [=map/exists=].

    1. Let |wellknown| be the result of running the [=fetch the well-known=] algorithm with the |provider|.

    1. Let |accounts list| be the result of running the [=fetch the accounts list=] algorithm.

    1. Let |account| be the result of running the [=select an account=] from the |accounts list| algorithm.

    1. If the {{StateMachine/Account State}} is [=unregistered=]

        1. Return the result of running the [=sign-up=] algorithm.

    1.  If the {{StateMachine/Session State}} is  [=logged out=] then

        1. Return the result of running the [=explicit sign-in=] algorithm.

    1. Return the result of running the [=auto sign-in=] algorithm.


To <dfn>sign-up</dfn> the user run this algorithm:

    1. Gather explicit intent to create an account

    1. Gather explicit agreement with the [=Privacy Policy=]

    1. Gather explicit agreement with the [=Terms of Service=]

    1. Set the account's {{StateMachine/Account State}} from [=unregistered=] to [=registered=].

    1. Set the account's {{StateMachine/Session State}} from [=logged out=] to [=logged in=].

    1. Return the result of [=minting=] a new [=id token=].

To <dfn>select an account</dfn> from the accounts list run this algorithm:

    1. If |accounts list|'s [=list/size=] is 1

        1. Let |account| be |accounts list|[0]

        1. Return |account|

    1. Display an account chooser
 
    1. Let |account| be an account that the user manually selects from the accounts chooser

    1. Return |account|

To <dfn>sign-in</dfn> the user run this algorithm:

    1. Assert that the {{StateMachine/Account State}} is [=registered=]

    1. Set the account's {{StateMachine/Session State}} from [=logged out=] to [=logged in=].

    1. Return the result of [=minting=] a new [=id token=].


To <dfn>auto sign-in</dfn> the user run this algorithm:

    1. Return the result of running the [=sign-in=] algorithm.


To <dfn>explicit sign-in</dfn> the user run this algorithm:

    1. Gather explicit confirmation that the user wants to sign-in to [=Relying Party=] with their [=Identity Provider=]'s |account|

    1. Return the result of running the [=sign-in=] algorithm.

To <dfn>fetch the well-known</dfn> configuration file, run this algorithm:

1. Let the |wellknown url| be the relative url ".well-known/webid" of |provider|["{{FederatedIdentityProvider/url}}"]

1. Return the result of fetching the |wellknown url| with the [[#Sec-WebID-CSR|Sec-WebID-CSR]] header but without the [=Identity Provider=]'s cookies.

To <dfn>fetch the accounts list</dfn> run this algorithm:

1. Let the |acccounts_endpoint| url be the relative url |wellknown|["{{WellKnown/accounts_endpoint}}"] of |provider|["{{FederatedIdentityProvider/url}}"]

1. Let the |accounts list| be the result of fetching the |accounts_endpoint| with the [=Identity Provider=]'s cookies.

1. Return the |accounts list|

To <dfn>fetch the client id metadata</dfn> run this algorithm:

1. Let the |client_id_metadata_endpoint| url be the relative url |wellknown|["{{WellKnown/client_id_metadata_endpoint}}"] of |provider|["{{FederatedIdentityProvider/url}}"]
1. Let the |policies| be the result of fetching the |client_id_metadata_endpoint| with the [[#Sec-WebID-CSR|Sec-WebID-CSR]] header but without the [=Identity Provider=]'s cookies.
1. Return |policies|

The <dfn>Privacy Policy</dfn> are the policies described at {{client_id_metadata_endpont_response/privacy_policy_url}}.

The <dfn>Terms of Service</dfn> are the policies described at {{client_id_metadata_endpont_response/terms_of_service_url}}.

To <dfn>mint a new id token</dfn>, run the following algorithm:

1. Let |token| be the result of making a POST request to the |wellknown|["{{WellKnown/idtoken_endpoint}}"] with:
    * Let the {{idtoken_endpoint_request/account_id}} be |account|["{{accounts_endpoint_response_accounts/account_id}}"].
    * Let the {{idtoken_endpoint_request/request}} be a new object with
        * Let {{idtoken_endpoint_request_request/client_id}} be |provider|["{{FederatedIdentityProvider/clientId}}"].
        * Let the {{idtoken_endpoint_request_request/nonce}} be |provider|["{{FederatedIdentityProvider/nonce}}"].
1. Return a new {{FederatedCredential}} as:
  * {{FederatedCredential/id}} with |account|["{{accounts_endpoint_response_accounts/account_id}}"]
  * {{FederatedCredential/idToken}} with |token|
  * {{FederatedCredential/provider}} with |provider|["{{FederatedIdentityProvider/url}}"]

<!-- ============================================================ -->
## The Revocation API ## {#revocation}
<!-- ============================================================ -->

Whenever the user decides to delete their account on the [=Relying Party=]
the [=Relying Party=] can call an API to let the [=Identity Provider=] and
the browser know.

Upon return to the [=Relying Party=], the user goes through a [[#use-cases-sign-up]] flow
instead of a [[#use-cases-sign-in]] flow.

<div class=example>
```js
async function revoke(accountId) {
  return await FederatedCredential.revoke(accountId);
}
```
</div>

This specification extends the {{FederatedCredential}} interface with an extra static method:

<xmp class=idl>
[Exposed=Window, SecureContext]
partial interface FederatedCredential : Credential {
  static Promise<void> revoke(USVString accountId);
};
</xmp>

Note: go over the revocation API.

<!-- ============================================================ -->
## The Sign-out API ## {#sign-out}
<!-- ============================================================ -->

<!-- ============================================================ -->
### RP Sign-out ### {#rp-sign-out}
<!-- ============================================================ -->

When a user wants to log out of their session in the [=Relying Party=],
the [=Relying Party=] can let the browser know that it wants the [[#use-cases-auto-sign-in]]
flow to be disabled, so that the user doesn't get into an infinite loop.

It does so by calling the `preventSilentAccess()` API, which clear the
user's current account session and takes them to an [[#use-cases-explicit-sign-in]] flow
whenever the user wants to log back in.

<div class=example>
```js
function logout() {
  navigator.credentials.preventSilentAccess();
}
```
</div>

Note: go over the RP sign-out API.

<!-- ============================================================ -->
### IDP Sign-out ### {#idp-sign-out}
<!-- ============================================================ -->

In enterprise scenarios, it is common for the user to want to clear all of
their existing sessions in all of the [=Relying Party=]s they are logged into.

It does so by being navigated to their [=Identity Provider=] who initiates
what's called a [[Front-Channel-Logout]].

The browser exposes an API that takes the list of [=Relying Party=]s that the
[=Identity Provider=] wants to initiate the logout which are loaded in parallel
with cookies.

Each [=Relying Party=] endpoint is responsible for clearing its local state
(e.g. clearing cookies).

After the completion of this API, the user's session is cleared and will go
through an [[#use-cases-explicit-sign-in]] upon return.

<div class=example>
```js
async function logout() {
  await FederatedCredential.logout([{
      endpoint: "https://rp1.example",
      accountId: "123",
    }, {
      endpiont: "https://rpN.example",
      accountId: "456",
    }]);
}
```
</div>

[=IDP=]s can call <code><a idl for="FederatedCredential" lt="get()">FederatedCredential.logout(...)</a></code> to log the user out of the [=RP=]s they are signed into.

<xmp class=idl>
dictionary WebIdLogoutRequest {
    required USVString endpoint;
    required USVString accountId;
};

[Exposed=Window, SecureContext]
partial interface FederatedCredential : Credential {
  static Promise<void> logout(optional sequence<WebIdLogoutRequest> logout_requests = []);
};
</xmp>

Note: go over how this is implemented.

<!-- ============================================================ -->
## Backwards Compatibility ## {#backwards-compatibility}
<!-- ============================================================ -->

<!-- ============================================================ -->
### Interceptors ### {#Interceptors}
<!-- ============================================================ -->

Note: go over how interceptors work.

<xmp class=idl>
[Exposed=Window, SecureContext]
partial interface FederatedCredential : Credential {
  static Promise<void> registerInterceptor(FederatedCredentialInterceptor interceptor);
};
</xmp>

<xmp class="idl">
dictionary FederatedCredentialInterceptor {
  DOMString url;
  sequence<DOMString> params;
};
</xmp>

<div dfn-type="dict-member" dfn-for="FederatedCredentialInterceptor">
    :   <dfn>url</dfn>
    ::  The url that points the browser to the .well-known configuration file.
    :   <dfn>params</dfn>
    ::  The URL request parameters to intercept navigations. 
</div>


<!-- ============================================================ -->
# Security # {#security}
<!-- ============================================================ -->

Note: go over security.

<!-- ============================================================ -->
# Privacy # {#privacy}
<!-- ============================================================ -->

Note: go over privacy.

<!-- ============================================================ -->
## Privacy Threat Model ## {#privacy-threat-model}
<!-- ============================================================ -->

Note: port the privacy threat model.

<!-- ====================================================================== -->
# Acknowledgements # {#acknowledgements}
<!-- ====================================================================== -->

Note: write down the Acknowledgements section.


<pre class="biblio">
{
  "OpenID": {
    "href": "https://openid.net/developers/specs/",
    "title": "OpenID"
  },
  "OAuth": {
    "authors": ["D. Hardt"],
    "href": "https://datatracker.ietf.org/doc/html/rfc6749",
    "title": "OAuth"
  },
  "SAML": {
    "href": "http://saml.xml.org/saml-specifications",
    "title": "SAML"
  },
  "JWT": {
    "authors": [ "M. Jones", "J. Bradley", "N. Sakimura" ],
    "href": "https://datatracker.ietf.org/doc/html/rfc7519",
    "title": "JWT"
  },
  "WEB-LOGIN": {
    "authors": [ "Jason Denizac", "Robin Berjon", "Anne van Kesteren" ],
    "href": "https://github.com/jden/web-login",
    "title": "web-login"
  },
  "BrowserID": {
    "href": "https://github.com/mozilla/id-specs/blob/prod/browserid/index.md",
    "title": "BrowserID"
  },
  "WebID": {
    "href": "https://www.w3.org/2005/Incubator/webid/spec/identity/",
    "title": "WebID"
  },
  "CM": {
    "href": "https://w3c.github.io/webappsec-credential-management/",
    "title": "Credential Management"
  },
  "Security-Origin-Confusion": {
    "href": "https://w3c.github.io/webappsec-credential-management/#security-origin-confusion",
    "title": "Security Origin Confusion"
  },
  "Unsanctioned-Web-Tracking": {
    "authors": [ "Mark Nottingham" ],
    "href": "https://www.w3.org/2001/tag/doc/unsanctioned-tracking/",
    "title": "Unsactioned Web Tracking"
  },
  "Front-Channel-Logout": {
    "authors": [ "M. Jones" ],
    "href": "https://openid.net/specs/openid-connect-frontchannel-1_0.html",
    "title": "Front-Channel Logout"
  },
  "Identity-Use-Cases-in-Browser-Catalog": {
    "authors": [ "V. Bertocci", "G. Fletcher" ],
    "href": "https://datatracker.ietf.org/doc/html/draft-bertocci-identity-in-browser-00",
    "title": "Identity Use Cases in Browser Catalog"
  }
}
</pre>