<pre class='metadata'>
Title: Identity Federation Management API
Shortname: webid
Level: 1
Status: CG-DRAFT
Group: WICG
ED: http://wicg.github.io/WebID
Repository: WICG/WebID
Editor: Sam Goto, Google Inc. https://google.com, goto@google.com
Markup Shorthands: markdown yes, css no, biblio yes
Default Biblio Display: inline
Text Macro: FALSE <code>false</code>
Text Macro: TRUE <code>true</code>
Text Macro: RP Relying Party
Text Macro: IDP Identity Provider
Abstract: This specification defines a set of [=high-level API=]s that enables users to continue to use [=Identity Provider=]s to authenticate to [=Relying Party=]s without incurring into [=unsactioned tracking=] on the Web. It accomplishes that by exposing the explicit user controls needed to manage the lifecycle of their federated accounts.
Test Suite: https://github.com/web-platform-tests/wpt/blob/master/credential-management/webid.https.html
</pre>

<pre class=anchors>
spec: ecma262; urlPrefix: https://tc39.github.io/ecma262/
    type: dfn
        text: time values; url: sec-time-values-and-time-range
        text: promise; url: sec-promise-objects

spec: credential-management-1; urlPrefix: https://w3c.github.io/webappsec-credential-management/
    type: dictionary
        text: CredentialRequestOptions; url: dictdef-credentialrequestoptions
    for: Credential
        type: method
            text: [[CollectFromCredentialStore]](origin, options, sameOriginWithAncestors)
            text: [[Create]](origin, options, sameOriginWithAncestors)
            text: [[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)
            text: [[Store]](credential, sameOriginWithAncestors)
    type: dfn
        text: signal
        text: same-origin with its ancestors; url: same-origin-with-its-ancestors
</pre>

<pre class=link-defaults>
spec:infra; type:dfn; text:list
spec:html; type:dfn; for:environment settings object; text:global object
spec:webidl; type:dfn; text:resolve
</pre>

<style>
dl.domintro dt {
    font-family: Menlo, Consolas, "DejaVu Sans Mono", Monaco, monospace;

    padding-top: 0.5em;
    padding-bottom: 1em;
}
dl.domintro dt a {
    color: inherit; border-bottom-style: none;
}
dl.domintro dt code {
    font-size: inherit;
}
</style>

<!-- ============================================================ -->
# Introduction # {#intro}
<!-- ============================================================ -->

*This section is non-normative.*

Over the last decade, identity federation has unquestionably played a central role in raising the bar for authentication on the web, in terms of ease-of-use (e.g. passwordless single sign-on), security (e.g. improved resistance to phishing and credential stuffing attacks) and trustworthiness compared to its preceding pattern: per-site usernames and passwords.

The standards that define how identity federation works today on the Web were built independently of the Web Platform (namely, [[SAML]], [[OpenID]] and [[OAuth]]), and their designers had to (rightfully so) work around its limitations rather than extend them.

Because of that, existing user authentication flows were designed on top of general-purpose web platform capabilities such as top-level navigations/redirects with parameters, window popups, iframes and cookies.

However, because these general purpose primitives can be used for an open ended number of use cases (again, notably, by design), browsers have to apply policies that capture the lowest common denominator of abuse, at best applying cumbersome permissions (e.g. popup blockers) and at worst entirely blocking them (e.g. blocking third party cookies).

Over the years, as these [=low-level API=]s get abused, browsers intervene and federation adjusts itself. For example, popup blockers became common and federation had to adjust itself to work in a world where popups blockers were widely deployed.

The challenge is that some of these low level primitives are getting increasingly abused to allow users on the web to be tracked. So, as a result, browsers are applying stricter and stricter policies around them.

This specification defines a set of [=high-level API=]s that serve as a foundation where identity federation on Web can thrive without incurring into [=unsactioned tracking=].

<!-- ============================================================ -->
# Use Cases # {#use-cases}
<!-- ============================================================ -->

The below use case scenarios illustrate some basic supported flows. Additional scenarios, including sample code, are given later in the [[Identity-Use-Cases-in-Browser-Catalog]].

<!-- ============================================================ -->
## Sign-up ## {#use-cases-sign-up}
<!-- ============================================================ -->

A Sign-up occurs when the user is registering a new account at the [=Relying Party=] using their [=Identity Provider=].

For example:

* A user navigates to a [=Relying Party=] in a browser and decides to create an account.
* The [=Relying Party=] supports multiple [=Identity Provider=] as an authentication mechanism.
* A user selects their favorite [=Identity Provider=] to sign-up with.
* The [=Identity Provider=] prompts, "Do you want to create an account with the [=Relying Party=]?"
* The user agrees.
* The [=Relying Party=] shows the message "Registration complete."
* An [=account=] in created in the [=Relying Party=] and a [=session=] initialized.

<!-- ============================================================ -->
## Sign-in ## {#use-cases-sign-in}
<!-- ============================================================ -->

After a user navigates to a [=Relying Party=] in a browser and decides to create an account by going through their [[#use-cases-sign-up]] flow, there are two ways a user logs into their [=account=] once their [=session=] expires:

<!-- ============================================================ -->
### Auto Sign-in ### {#use-cases-auto-sign-in}
<!-- ============================================================ -->

Auto Sign-in occurs when the [=Identity Provider=] has already gathered enough permission from the user to share their identity that it doesn't block on gathering further permission and automatically signs the user in.

For example:

* Using another device (e.g. their laptop):
    * The user goes to the [=Relying Party=].
    * The user selects their favorite [=Identity Provider=] to sign-in.
    * The [=Identity Provider=] remembers and proves that the user already has an [=account=] with the [=Relying Party=].
    * The [=Relying Party=] creates a new [=session=] for the user's existing [=account=].

<!-- ============================================================ -->
### Explicit Sign-in ### {#use-cases-explicit-sign-in}
<!-- ============================================================ -->

An explicit sign-in occurs when the [=Identity Provider=] believes it is necessary to gather an explicit permission from the user to sign into a [=Relying Party=], typically after the user goes through a [[#use-cases-sign-out]] flow.

For example:

* The user decides to [[#use-cases-sign-out]] of the [=Relying Party=]

A few months later:

* The user navigates to the [=Relying Party=]
* The user selects their favorite [=Identity Provider=] to sign-in again.
* The [=Identity Provider=] knows that:
    * the user already has an account with the [=Relying Party=].
    * the user has logged out of the [=Relying Party=].
* The [=Identity Provider=] prompts, "Do you want to sign-in with the [=Relying Party=]?"
* The user agrees.
* The [=Relying Party=] creates a new [=session=] for the user's existing [=account=].

<!-- ============================================================ -->
## Sign-out ## {#use-cases-sign-out}
<!-- ============================================================ -->

After a user navigates to a [=Relying Party=] in a browser and decides to create an [=account=] by going through their [[#use-cases-sign-up]] flow, there are two ways a user can clear their [=session=]s:

<!-- ============================================================ -->
### RP Sign-out ### {#use-cases-rp-sign-out}
<!-- ============================================================ -->

* On a shared computer:
    * The user decides to close their session and logs out of the [=Relying Party=].
    * The user is now logged out of the [=Relying Party=].
    * Upon return to the [=Relying Party=], the user expects to go through an [[#use-cases-explicit-sign-in]].

<!-- ============================================================ -->
### IDP Sign-out ### {#use-cases-idp-sign-out}
<!-- ============================================================ -->

* On a shared computer:
    * The user decides to close their [=session=] and logs out of the [=Relying Party=].
    * The [=Relying Party=] lets the [=Identity Provider=] know that the user wants to logout.
    * The [=Identity Provider=] logs the user out of all of the [=Relying Party=]s and itself.
    * Upon return to the [=Relying Party=], the goes through an [[#use-cases-explicit-sign-in]].

<!-- ============================================================ -->
## Revocation ## {#use-cases-revocation}
<!-- ============================================================ -->

After a user navigates to a [=Relying Party=] in a browser and decides to create an account by going through their [[#use-cases-sign-up]] flow, there are two ways a user can cancel their account:

<!-- ============================================================ -->
### IDP Revocation ### {#use-cases-idp-revocation}
<!-- ============================================================ -->

* On the [=Identity Provider=]:
    * The user decides to cancel their account.
    * The user goes to their [=Identity Provider=] and revokes access to the [=Relying Party=].
    * Upon return to the [=Relying Party=], the user expects to go through a [[#use-cases-sign-up]].  

<!-- ============================================================ -->
### RP Revocation ### {#use-cases-rp-revocation}
<!-- ============================================================ -->

* On the [=Relying Party=]:
    * The user decides to cancel their account.
    * The user navigates to the [=Relying Party=] and cancels their account, also letting the [=Identity Provider=] know.
    * Upon return to the [=Relying Party=], the user expects to go through a [[#sign-up]].  

<!-- ============================================================ -->
## Access ## {#Access}
<!-- ============================================================ -->

* A user navigates to a [=Relying Party=] in a browser and decides to create an [=account=].
* The [=Relying Party=] supports multiple [=Identity Provider=] which provide access to the user's Calendar.
* A user selects their favorite [=Identity Provider=] to sign-up with.
* The [=Identity Provider=] prompts, "Do you want to give access to your Calendar to the [=Relying Party=]?"
* The user agrees.
* The [=Relying Party=] shows message, "Registration complete.", creates a [=session=] for the user and
* Shows the user their calendar entries provided by the [=Identity Provider=].

<!-- ============================================================ -->
# Examples # {#examples}
<!-- ============================================================ -->

<!-- ============================================================ -->
## Signing-up and Signing-in ## {#examples-signing-up-and-signing-in}
<!-- ============================================================ -->

The Sign-up and Sign-in APIs are APIs used by the [=Relying Party=]s to ask the browser to intermediate the relationship with the [=Identity Provider=] and the provisioning of an [=id token=].

The [=Relying Party=] makes no delineation between Sign-up and Sign-in, but rather call the same API indistinguishably. The most important parameter to the API call is the set of [=Identity Provider=]s that the [=Relying Party=] supports and has pre-registered with (i.e. it has a `clientId`).

Additionally, the [=Relying Party=] can control a variety of UX knobs. For example, whether to allow an [[#use-cases-auto-sign-in]] flow and an AbortSignal in case it needs to abort the flow.

If all goes well, the [=Relying Party=] receives back an [=id token=] in the form of a signed [[JWT]] which it can use to authenticate the user.

<div class=example>
```js
async function login(signal) {
  const {idToken} = await navigator.credentials.get({
    // controls whether auto sign-in is enabled or not
    mediation: "optional",
    // controls abortions of the account chooser
    signal: signal

    // controls which identity providers to use
    federated: {
      // controls which UX mode to use
      mode: "mediated",
      // controls whether the account chooser is modal or not
      providers: [{
        url: "https://idp.example",
        // the pre-registered client id  
        clientId: "123",
        nonce: "456"
      }],
    }
  });

  return idToken;
}
```
</div>

<!-- ============================================================ -->
## Signing-out ## {#examples-signing-out}
<!-- ============================================================ -->

<!-- ============================================================ -->
### RP Sign-out ### {#examples-rp-sign-out}
<!-- ============================================================ -->

When a user wants to log out of their session in the [=Relying Party=],
the [=Relying Party=] can let the browser know that it wants the [[#use-cases-auto-sign-in]]
flow to be disabled, so that the user doesn't get into an infinite loop.

It does so by calling the `preventSilentAccess()` API, which clear the
user's current account session and takes them to an [[#use-cases-explicit-sign-in]] flow
whenever the user wants to log back in.

<div class=example>
```js
function logout() {
  navigator.credentials.preventSilentAccess();
}
```
</div>

<!-- ============================================================ -->
### Front-channel Sign-out ### {#examples-front-channel-sign-out}
<!-- ============================================================ -->

In enterprise scenarios, it is common for the user to want to clear all of
their existing sessions in all of the [=Relying Party=]s they are logged into.

It does so by being navigated to their [=Identity Provider=] who initiates
what's called a [[Front-Channel-Logout]].

The browser exposes an API that takes the list of [=Relying Party=]s that the
[=Identity Provider=] wants to initiate the logout which are loaded in parallel
with cookies.

Each [=Relying Party=] endpoint is responsible for clearing its local state
(e.g. clearing cookies).

After the completion of this API, the user's session is cleared and will go
through an [[#use-cases-explicit-sign-in]] upon return.

<div class=example>
```js
async function logout() {
  await FederatedCredential.logout([{
      endpoint: "https://rp1.example",
      accountId: "123",
    }, {
      endpiont: "https://rpN.example",
      accountId: "456",
    }]);
}
```
</div>

<!-- ============================================================ -->
## RP Revocation ## {#examples-rp-revocation}
<!-- ============================================================ -->

Whenever the user decides to delete their account on the [=Relying Party=]
the [=Relying Party=] can call an API to let the [=Identity Provider=] and
the browser know.

Upon return to the [=Relying Party=], the user goes through a [[#use-cases-sign-up]] flow
instead of a [[#use-cases-sign-in]] flow.

<div class=example>
```js
async function revoke(accountId) {
  return await FederatedCredential.revoke(accountId);
}
```
</div>

<!-- ============================================================ -->
## Feature Detection ## {#intro-feature-detection}
<!-- ============================================================ -->

<div class=example>
```js
if (!window.FederatedCredential) {
  // feature not available
  // TODO(goto): this is probably insufficient.
  return;
}
```
</div>

<!-- ============================================================ -->
# Terminology # {#terminology}
<!-- ============================================================ -->

: <dfn>Relying Party</dfn>
: <dfn>RP</dfn>
: <dfn>Website</dfn>
:: TODO(goto): find existing definitions.

: <dfn>Identity Provider</dfn>
: <dfn>IDP</dfn>
:: TODO(goto): find existing definition.

: <dfn>session</dfn>
:: TODO(goto: find existing definition.

: <dfn>account</dfn>
:: TODO(goto: find existing definition.

: <dfn>id token</dfn>
:: TODO(goto: find existing definition.

: <df>unsactioned tracking</dfn>
:: The type of tracking on the web described in [[Unsanctioned-Web-Tracking]].

: <dfn>high-level API</dfn>
:: A use case specific API, as opposed to a [=low-level API=].

: <dfn>low-level API</dfn>
:: A general purpose API, as opposed to a [=high-level API=].

: <dfn>registered</dfn>
:: TODO(goto: find existing definition.

: <dfn>unregistered</dfn>
:: TODO(goto: find existing definition.

: <dfn>logged in</dfn>
:: TODO(goto: find existing definition.

: <dfn>logged out</dfn>
:: TODO(goto: find existing definition.

<!-- ============================================================ -->
# High Level Design # {#lifecycle}
<!-- ============================================================ -->

The account management and session management APIs allows the user to explicitly move through the different stages of their accounts. At each stage, the state machine manages the [=RP=]'s and the [=IDP=]'s access to the appropriate browser capabilities.

User agents MUST internally provide storage for a <dfn export id="concept-state-machine">state machine</dfn> that keeps track of the lifecycle of the accounts of [=IDP=] being used at [=RP=].

<img src="static/mock42.svg">

<dl dfn-type="argument" dfn-for="StateMachine">
    :   <dfn>Account State</dfn>
    ::  Keeps track of whether the user has an account or not. Can be [=registered=] or (by default) [=unregistered=].
    :   <dfn>Session State</dfn>
    ::  Keeps track of whether the user has an open or closed session. Can be [=logged in=] or (by default) [=logged out=].
</dl>

<img src="static/mock43.svg">

<!-- ============================================================ -->
# The Identity Provider API # {#idp-api}
<!-- ============================================================ -->

<!-- ============================================================ -->
## The .well-known/webid configuration ## {#Well-Known}
<!-- ============================================================ -->

<dl dfn-type="argument" dfn-for="WellKnown">
    :   <dfn>accounts_endpoint</dfn>
    ::  A relative URL that points to an HTTP API that complies with the [[#accounts_endpoint]].
    :   <dfn>idtoken_endpoint</dfn>
    ::  A relative URL that points to an HTTP API that complies with the [[#idtoken_endpoint]].
    :   <dfn>client_id_metadata_endpoint</dfn>
    ::  A relative URL that points to an HTTP API that complies with the [[#client_id_metadata_endpoint]].
</dl>

To <dfn>fetch the well-known</dfn> configuration file, run this algorithm:

1. Let the |wellknown url| be the relative url ".well-known/webid" of |provider|["{{FederatedIdentityProvider/url}}"]
1. Return the result of fetching the |wellknown url| with the [[#Sec-WebID-CSR|Sec-WebID-CSR]] header but without the [=Identity Provider=]'s cookies.

<!-- ============================================================ -->
### <code><dfn data-export="">`Sec-WebID-CSR`</dfn></code> ### {#Sec-WebID-CSR}
<!-- ============================================================ -->

<!-- ============================================================ -->
## accounts_endpoint ## {#accounts_endpoint}
<!-- ============================================================ -->

To <dfn>fetch the accounts list</dfn> run this algorithm:

1. Let the |acccounts_endpoint| url be the relative url |wellknown|["{{WellKnown/accounts_endpoint}}"] of |provider|["{{FederatedIdentityProvider/url}}"]
1. Let the |accounts list| be the result of fetching the |accounts_endpoint| with the [=Identity Provider=]'s cookies.
1. Return the |accounts list|

<!-- ============================================================ -->
### The accounts list request  ### {#accounts_endpoint_request}
<!-- ============================================================ -->

<!-- ============================================================ -->
### The accounts list response  ### {#accounts_endpoint_response}
<!-- ============================================================ -->

<dl dfn-type="argument" dfn-for="accounts_endpoint_response">
    :   <dfn>accounts</dfn>
    ::  A list of [[#accounts_endpoint_response_accounts]].
</dl>

<!-- ============================================================ -->
#### Account  #### {#accounts_endpoint_response_accounts}
<!-- ============================================================ -->

<dl dfn-type="argument" dfn-for="accounts_endpoint_response_accounts">
    :   <dfn>account_id</dfn>
    ::  An account identifier.
    :   <dfn>name</dfn>
    ::  The user's name.
    :   <dfn>email</dfn>
    ::  The user's email address.
    :   <dfn>picture</dfn>
    :: The user's profile picture.
</dl>

<!-- ============================================================ -->
## idtoken_endpoint ## {#idtoken_endpoint}
<!-- ============================================================ -->

<!-- ============================================================ -->
### <dfn for="Minting">Minting</dfn> a new IdToken ### {#minting}
<!-- ============================================================ -->

    To mint a new id token, run the following algorithm:

    1. Let |token| be the result of making a POST request to the |wellknown|["{{WellKnown/idtoken_endpoint}}"] with:
        * Let the {{idtoken_endpoint_request/account_id}} be |account|["{{accounts_endpoint_response_accounts/account_id}}"].
        * Let the {{idtoken_endpoint_request/request}} be a new object with
              * Let {{idtoken_endpoint_request_request/client_id}} be |provider|["{{FederatedIdentityProvider/clientId}}"].
              * Let the {{idtoken_endpoint_request_request/nonce}} be |provider|["{{FederatedIdentityProvider/nonce}}"].

    1. Return a new {{FederatedCredential}} as:
        * {{FederatedCredential/id}} with |account|["{{accounts_endpoint_response_accounts/account_id}}"]
        * {{FederatedCredential/idToken}} with |token|
        * {{FederatedCredential/provider}} with |provider|["{{FederatedIdentityProvider/url}}"]

<!-- ============================================================ -->
### The idtoken request  ### {#idtoken_endpoint_request}
<!-- ============================================================ -->

<dl dfn-type="argument" dfn-for="idtoken_endpoint_request">
    :   <dfn>account_id</dfn>
    :: An account identifier.
    :   <dfn>request</dfn>
</dl>

<dl dfn-type="argument" dfn-for="idtoken_endpoint_request_request">
    :   <dfn>client_id</dfn>
    :   <dfn>nonce</dfn>
</dl>

<!-- ============================================================ -->
### The idtoken response  ### {#idtoken_endpoint_response}
<!-- ============================================================ -->

<dl dfn-type="argument" dfn-for="idtoken_endpoint_response">
    :   <dfn>id_token</dfn>
    ::  An [=id token=].
</dl>

<!-- ============================================================ -->
## client_id_metadata_endpoint ## {#client_id_metadata_endpoint}
<!-- ============================================================ -->

The [=.well-known=]'s <code><dfn data-export="" data-dfn-for=".well-known">`client_id_metadata_endpoint`</dfn></code> 

To <dfn>fetch the client id metadata</dfn> run this algorithm:

1. Let the |client_id_metadata_endpoint| url be the relative url |wellknown|["{{WellKnown/client_id_metadata_endpoint}}"] of |provider|["{{FederatedIdentityProvider/url}}"]
1. Let the |policies| be the result of fetching the |client_id_metadata_endpoint| with the [[#Sec-WebID-CSR|Sec-WebID-CSR]] header but without the [=Identity Provider=]'s cookies.
1. Return |policies|

<!-- ============================================================ -->
### The client_id metadata request  ### {#client_id_metadata_endpoint_request}
<!-- ============================================================ -->

<!-- ============================================================ -->
### The client_id metadata response  ### {#client_id_metadata_endpoint_response}
<!-- ============================================================ -->

The <dfn>Privacy Policy</dfn> are the policies described at {{client_id_metadata_endpont_response/privacy_policy_url}}.

The <dfn>Terms of Service</dfn> are the policies described at {{client_id_metadata_endpont_response/terms_of_service_url}}.

<dl dfn-type="argument" dfn-for="client_id_metadata_endpont_response">
    :   <dfn>privacy_policy_url</dfn>
    ::  A link to the [=Relying Party=]'s privacy policy.
    :   <dfn>terms_of_service_url</dfn>
    ::  A link to the [=Relying Party=]'s terms of service.
</dl>

<!-- ============================================================ -->
# The Relying Party API # {#rp-api}
<!-- ============================================================ -->

<!-- ============================================================ -->
# The Browser API # {#API}
<!-- ============================================================ -->

Websites call <code><a idl for="CredentialsContainer" lt="get()">navigator.credentials.get({providers:..., ...})</a></code> to retrieve a {{FederatedCredential}}.

<!-- ============================================================ -->
## The Sign-in API ## {#sign-in}
<!-- ============================================================ -->

<!-- ============================================================ -->
### The {{FederatedCredential}} Interface ### {#FederatedCredential}
<!-- ============================================================ -->

This specification extends the {{FederatedCredential}} type adding two more fields:

<xmp class=idl>
[Exposed=Window, SecureContext]
partial interface FederatedCredential : Credential {
  readonly attribute USVString idToken;
  readonly attribute FederatedCredentialApprover approvedBy;
};
</xmp>

<dl dfn-type="attribute" dfn-for="FederatedCredential">
    :   {{idToken}}
    ::  The [=id token=].

    :   {{approvedBy}}
    ::  When used in conjunction with {{CredentialRequestOptions/mediation}}, it indicates whether the credential was provided via a [[#use-cases-auto-sign-in]] or an [[#use-cases-explicit-sign-in]].
</dl>

<!-- ============================================================ -->
### The {{FederatedCredentialRequestOptions}} ### {#FederatedCredentialRequestOptions}
<!-- ============================================================ -->

It also extends the {{FederatedCredentialRequestOptions}} by adding a list of {{FederatedIdentityProvider}}s as well as the UX controls for modality and modes.

<xmp class=idl>
partial dictionary FederatedCredentialRequestOptions {
  sequence<(DOMString or FederatedIdentityProvider)> providers;
  FederatedCredentialRequestMode mode = "mediated";
};

dictionary FederatedIdentityProvider {
  required USVString url;
  USVString clientId;
  USVString nonce;
};

enum FederatedCredentialRequestMode {
  "mediated",
  "permission"
};

enum FederatedCredentialApprovedBy {
  "auto",
  "user"
};
</xmp>

<!-- ============================================================ -->
### The {{FederatedCredential}}'s <code><dfn for="FederatedCredential" method>\[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)</dfn></code> Method ### {#federated-credential-discover-from-external-source}
<!-- ============================================================ -->

This algorithm runs in parallel inside the [[CM#algorithm-request]] to request credentials and returns a set of {{FederatedCredential}} objects from a remote [=Identity Provider=].

This [=internal method=] accepts three arguments:

<dl dfn-type="argument" dfn-for="FederatedCredential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)">

    :   <dfn>origin</dfn>
    ::  This argument is the [=relevant settings object=]'s [=environment settings object/origin=], as determined by the
        calling {{CredentialsContainer/get()}} implementation, i.e., {{CredentialsContainer}}'s <a abstract-op>Request a `Credential`</a> abstract operation.

    :   <dfn>options</dfn>
    ::  This argument is a {{CredentialRequestOptions}} object whose
        <code>|options|.{{CredentialRequestOptions/federated}}</code> member contains a {{FederatedCredentialRequestOptions}}
        object specifying the exchange options.

    :   <dfn>sameOriginWithAncestors</dfn>
    ::  This argument is a Boolean value which is [TRUE] if and only if the caller's [=environment settings object=] is
        [=same-origin with its ancestors=]. It is [FALSE] if caller is cross-origin.
</dl>

Note: <strong>This algorithm is synchronous:</strong> the {{Promise}} resolution/rejection is handled by
{{CredentialsContainer/get()|navigator.credentials.get()}}.

When this method is invoked, the user agent MUST execute the following algorithm:

    1.  If <var ignore>sameOriginWithAncestors</var> is `false`, return a "{{NotAllowedError}}" {{DOMException}}.

        Note: This restriction aims to address the concern raised in [[Security-Origin-Confusion]].

    1.  Assert: |options|["{{CredentialRequestOptions/federated}}"]["{{FederatedCredentialRequestOptions/providers}}"] [=map/exists=].

    1.  Assert: |options|["{{CredentialRequestOptions/federated}}"]["{{FederatedCredentialRequestOptions/providers}}"] [=list/size=] is 1.

        Note: At some point we would like to support choosing accounts from multiple [=Identity Provider=]s.

    1. Let |provider| be |options|["{{CredentialRequestOptions/federated}}"]["{{FederatedCredentialRequestOptions/providers}}"][0].

    1. Assert: |provider|["{{FederatedIdentityProvider/url}}"] [=map/exists=].

    1. Assert: |provider|["{{FederatedIdentityProvider/clientId}}"] [=map/exists=].

    1. Assert: |provider|["{{FederatedIdentityProvider/nonce}}"] [=map/exists=].

    1. Let |wellknown| be the result of running the [=fetch the well-known=] algorithm with the |provider|.

    1. Let |accounts list| be the result of running the [=fetch the accounts list=] algorithm.

    1. Let |account| be the result of running the [=select an account=] from the |accounts list| algorithm.

    1. If the {{StateMachine/Account State}} is [=unregistered=]

        1. Return the result of running the [=sign-up=] algorithm.

    1.  If the {{StateMachine/Session State}} is  [=logged out=] then

        1. Return the result of running the [=explicit sign-in=] algorithm.

    1. Return the result of running the [=auto sign-in=] algorithm.


To <dfn>sign-up</dfn> the user run this algorithm:

    1. Gather explicit intent to create an account

    1. Gather explicit agreement with the [=Privacy Policy=]

    1. Gather explicit agreement with the [=Terms of Service=]

    1. Set the account's {{StateMachine/Account State}} from [=unregistered=] to [=registered=].

    1. Set the account's {{StateMachine/Session State}} from [=logged out=] to [=logged in=].

    1. Return the result of [=minting=] a new [=id token=].

To <dfn>select an account</dfn> from the accounts list run this algorithm:

    1. If |accounts list|'s [=list/size=] is 1

        1. Let |account| be |accounts list|[0]

        1. Return |account|

    1. Display an account chooser
 
    1. Let |account| be an account that the user manually selects from the accounts chooser

    1. Return |account|


To <dfn>sign-in</dfn> the user run this algorithm:

    1. Assert that the {{StateMachine/Account State}} is [=registered=]

    1. Set the account's {{StateMachine/Session State}} from [=logged out=] to [=logged in=].

    1. Return the result of [=minting=] a new [=id token=].


To <dfn>auto sign-in</dfn> the user run this algorithm:

    1. Return the result of running the [=sign-in=] algorithm.


To <dfn>explicit sign-in</dfn> the user run this algorithm:

    1. Gather explicit confirmation that the user wants to sign-in to [=Relying Party=] with their [=Identity Provider=]'s |account|

    1. Return the result of running the [=sign-in=] algorithm.

<!-- ============================================================ -->
### Interceptors ### {#Interceptors}
<!-- ============================================================ -->

<xmp class=idl>
[Exposed=Window, SecureContext]
partial interface FederatedCredential : Credential {
  static Promise<void> registerInterceptor(FederatedCredentialInterceptor interceptor);
};
</xmp>

<!-- ============================================================ -->
#### `FederatedCredentialInterceptor` #### {#FederatedCredentialInterceptor}
<!-- ============================================================ -->

<xmp class="idl">
dictionary FederatedCredentialInterceptor {
  DOMString url;
  sequence<DOMString> params;
};
</xmp>

<div dfn-type="dict-member" dfn-for="FederatedCredentialInterceptor">
    :   <dfn>url</dfn>
    ::  The url that points the browser to the .well-known configuration file.
    :   <dfn>params</dfn>
    ::  The URL request parameters to intercept navigations. 
</div>

<!-- ============================================================ -->
## The Revocation API ## {#revocation}
<!-- ============================================================ -->

<xmp class=idl>
[Exposed=Window, SecureContext]
partial interface FederatedCredential : Credential {
  static Promise<void> revoke(USVString accountId);
};
</xmp>

<!-- ============================================================ -->
## The Sign-out API ## {#sign-out}
<!-- ============================================================ -->

<!-- ============================================================ -->
### RP Sign-out ### {#rp-sign-out}
<!-- ============================================================ -->

<!-- ============================================================ -->
### IDP Sign-out ### {#idp-sign-out}
<!-- ============================================================ -->

Websites call <code><a idl for="FederatedCredential" lt="get()">FederatedCredential.logout(...)</a></code> to log the user out of a series of relying parties.

<xmp class=idl>
[Exposed=Window, SecureContext]
partial interface FederatedCredential : Credential {
  static Promise<void> logout(optional sequence<USVString> logout_endpoints = []);
};
</xmp>


<!-- ============================================================ -->
# Security # {#security}
<!-- ============================================================ -->

<!-- ============================================================ -->
# Privacy # {#privacy}
<!-- ============================================================ -->

<!-- ============================================================ -->
## Privacy Threat Model ## {#privacy-threat-model}
<!-- ============================================================ -->

<!-- ====================================================================== -->
# Acknowledgements # {#acknowledgements}
<!-- ====================================================================== -->


<pre class="biblio">
{
  "OpenID": {
    "href": "https://openid.net/developers/specs/",
    "title": "OpenID"
  },
  "OAuth": {
    "authors": ["D. Hardt"],
    "href": "https://datatracker.ietf.org/doc/html/rfc6749",
    "title": "OAuth"
  },
  "SAML": {
    "href": "http://saml.xml.org/saml-specifications",
    "title": "SAML"
  },
  "JWT": {
    "authors": [ "M. Jones", "J. Bradley", "N. Sakimura" ],
    "href": "https://datatracker.ietf.org/doc/html/rfc7519",
    "title": "JWT"
  },
  "WEB-LOGIN": {
    "authors": [ "Jason Denizac", "Robin Berjon", "Anne van Kesteren" ],
    "href": "https://github.com/jden/web-login",
    "title": "web-login"
  },
  "BrowserID": {
    "href": "https://github.com/mozilla/id-specs/blob/prod/browserid/index.md",
    "title": "BrowserID"
  },
  "WebID": {
    "href": "https://www.w3.org/2005/Incubator/webid/spec/identity/",
    "title": "WebID"
  },
  "CM": {
    "href": "https://w3c.github.io/webappsec-credential-management/",
    "title": "Credential Management"
  },
  "Security-Origin-Confusion": {
    "href": "https://w3c.github.io/webappsec-credential-management/#security-origin-confusion",
    "title": "Security Origin Confusion"
  },
  "Unsanctioned-Web-Tracking": {
    "authors": [ "Mark Nottingham" ],
    "href": "https://www.w3.org/2001/tag/doc/unsanctioned-tracking/",
    "title": "Unsactioned Web Tracking"
  },
  "Front-Channel-Logout": {
    "authors": [ "M. Jones" ],
    "href": "https://openid.net/specs/openid-connect-frontchannel-1_0.html",
    "title": "Front-Channel Logout"
  },
  "Identity-Use-Cases-in-Browser-Catalog": {
    "authors": [ "V. Bertocci", "G. Fletcher" ],
    "href": "https://datatracker.ietf.org/doc/html/draft-bertocci-identity-in-browser-00",
    "title": "Identity Use Cases in Browser Catalog"
  }
}
</pre>