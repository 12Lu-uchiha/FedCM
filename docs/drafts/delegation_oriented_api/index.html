<h1>Delegation-oriented API</h1>
<p>This approach attempts to provide technical enforcements of <a href="glossary.md#identity-provider-blindness">Identity Provider
blindness</a> by having the IDP delegate
the generation of identity assertion to the browser.</p>
<p>Below is one variation that combines the IDP blindness mechanisms designed in
<a href="https://en.wikipedia.org/wiki/Mozilla_Persona">Mozillaâ€™s Personas proposal</a>
with the <a href="glossary.md#relying-party-blindness">RP blindness</a>, recovery processes
and the user-behavior backwards compatibility. This approach maximizes the
technical enforcement of both RP and IDP tracking, at the cost of IDP and RP
server-side backwards compatibility.</p>
<h2>Basic Flow</h2>
<figure>
  <img src="./static/delegation-api-flow.svg" alt="High-level flow diagram for delegation-oriented approach" />
  <figcaption>High-level flow diagram for delegation-oriented approach</figcaption>
</figure>
<p>Notice that in this approach we are assuming that an email proxy and email
provider exist independent from the IDP. This is necessary to maintain IDP
blindness even after RP uses the directed email address to email the user.</p>
<p>Below is the sign up flow in this proposal where a user signs up to an RP and
share their <a href="glossary.md#directed-basic-profile">directed basic profile</a>. The
importance of recovery code and salt are discussed in the next section.</p>
<figure>
  <img src="./static/delegation-api-signup-flow.svg" alt="Sign-Up Flow for a WebID enabled browser" />
  <figcaption>Sign-Up Flow for a WebID enabled browser</figcaption>
</figure>
<p>Description of the steps involved in this flow:</p>
<ol>
<li>RP initiates the sign-up through
<a href="consumers.md#the-consumer-api">the consumer API</a></li>
<li>Browser obtains the designated IDP endpoint as declared in a <code>.well-known</code>
configuration.</li>
<li>Browser sends the user to the designated IDP end point to obtain the global
account and a list of directed accounts for the current user.
<ul>
<li>Note that the RP is not exposed to the IDP.</li>
<li>As part of this step IDP may show UI and authenticate the user.</li>
<li>In this example the list of directed accounts is empty given that this is
a first sign-up moment.</li>
</ul>
</li>
<li>Browser sees no directed account in the IDP response and initiates its
account creation process.
<ul>
<li>It is possible that the directed accounts list is not empty and has a
matching entry for the current RP. This occurs for a retuning user sign-in
and means that the browser already has account details including a private
key for the user and can skip most of the following steps.</li>
</ul>
</li>
<li>Browser coordinates with Email Proxy service to obtain a directed email for
the user.
<ul>
<li>This step only assumes that an Email Proxy separate from the IDP exists.
This process may involves additional steps which are not relevant at this
stage. See [#decoupling-idp-from-email-services] for more details.</li>
</ul>
</li>
<li>Browser generates a new key pair and a random salt value.</li>
<li>Browser sends the public key, salt, and directed email address to the IDP.</li>
<li>IDP return a certificate signed with its own private key. The certificate
includes browser generated public key, and directed email.
<ul>
<li>IDP remembers [browser public key, directed email, and salt] as a new
directed account for the user. This is used for future sign-ins.</li>
</ul>
</li>
<li>Browser receives the certification and adds the new directed account to its
database.</li>
<li>Browser creates a recovery code for the new account in its database.
<ul>
<li>Recover code is <code>SHA512(alice, salt, RP)</code></li>
</ul>
</li>
<li>Browser generates an <a href="#certified-jwt">Certified JWT</a> as <code>id_token</code> and signs
it with its own privte key.
<ul>
<li>The token includes [directed identifier, directed email, and the recovery
code].</li>
</ul>
</li>
<li>Browser returns the certified <code>id_token</code> to RP.</li>
<li>RP verifies the certified <code>id_token</code> and signs up the user.
<ul>
<li>The verification process involves both the browser public key and the IDP
public key. Additional details are available in the
<a href="#rp-backend-verification">RP backend verification section</a>.</li>
<li>RP stores the recovery code in addition to the user directed identifier.
The recovery code allows RP to sign in the user even in absence of WebID.
See <a href="#recovery-flow">recovery flow</a> for more details.</li>
</ul>
</li>
</ol>
<h2>Benefits</h2>
<p>Maximum IDP and RP tracking preventions using technical enforcement.</p>
<p>From a UX perspective, we expect this to have the lowest privacy-introduced
friction/consent, since both RP and IDP tracking problems are addressed
mechanically.</p>
<h2>Challenges</h2>
<h3>Server-side Backward compatibility</h3>
<p>This approach requires changes in the RP backends:</p>
<ul>
<li>This approach requires a new token format which is no longer backward
compatible with the OpenID JWT. This means that the token verification
libraries on the RP backends need to be updated. While we can do our best to
make the change small, all RPs are  still required to redeploy. In contrast,
earlier explored flows only require IDP sdk and backend updates.</li>
<li>The RP needs to maintain a recovery token for each account. This is necessary
to enable the ability for users to sign-in to their account on platforms that
don't have WebID or after they switch browsers.</li>
</ul>
<h3>UX Complication</h3>
<p>With this proposal the sign-in user experience on RP would remain the same in
particular a) users can sign in to RP by selecting an IDP and b) users can sign
in to their existing account with RP even on platforms that do not support WebID
by falling back to OpenID and removing IDP blindness restriction.</p>
<p>However the user experience on IDP side changes. In particular users are no
longer able to see and manage all the RPs they have signed up with through their
IDP control panel. Browsers may be able to provide a similar UX. Most likely
scenario is that both browser and IDP would end up managing some account which
can be a source of confusion.</p>
<h3>Decoupling IDP from Email Services</h3>
<p>A <a href="glossary.html#directed-basic-profile">directed email address</a> requires an
email proxy service in addition to the email provider.</p>
<p>One option is for the email provider to be the email proxy as well. This seems
like a reasonable option.</p>
<p>Another seemingly natural option would be to have the IDP provide the email
proxy service. However this can weaken the IDP blindness if IDP is also either
the email proxy or email provider. This is beucase most RPs send a welcome email
to their users on account creation.</p>
<p>So to mitigate this risk, we envision an entity (or entities) different from the
IDP is responsible for proxying email and keeping the user inbox. At this stage
and for the purpose of the flows discussed here, we simply assume the key
property that separate IDP and Email Proxy/Provider exists and paper over the
details of how a directed email address is created and verified across email
proxy, email provider and IDP.</p>
<h3>RP account management complexity</h3>
<p>Directed emails notably increase account management complexity for RPs since
many users are not be able to readily recall their directed email address. This
proposal adds even more complexity to this by introducing email proxy to the
mix.</p>
<h2>Technical Details</h2>
<h3>IDP/RP Blindness Enforcement</h3>
<ul>
<li>the IDP is not aware of the RP that the user is signing in. This is achieved
by having the IDP certify a browser controlled public key whose private key
can be used to mint new tokens on IDP's behalf.</li>
<li>This enforced IDP blindness may be reverted when it becomes necessary. We
belive one such necessary use case is to allow a user to sign in to their
account on platforms that do not support WebID.</li>
<li>the RP is always blind as it receives directed id and directed email.</li>
</ul>
<h3>Databases</h3>
<p>Here is the database for each of the participating entities.</p>
<ul>
<li><strong>Browser</strong>: RP, IDP, global user id, private/public key pair, global email, directed email, salt, IDP certificate</li>
<li><strong>Email Proxy</strong>: directed email, global email</li>
<li><strong>IDP</strong>: user id, directed id, directed email, public key, salt</li>
<li><strong>RP</strong>: directed email, directed id, recovery code</li>
</ul>
<h3>RP Backend Verification</h3>
<p>Normally the RP verifies the <a href="https://tools.ietf.org/html/rfc7519">JWT</a> (JSON Web Token) on its backend by checking
its signature against the IDP public key. However the new proposed Certified JWT
contains, in its header, a browser generated public key which is certified by
the IDP. So the verification process first verifies the included public key with
the IDP public key and then verifies the token using this public key.</p>
<h4>Certified JWT</h4>
<p>Here is a strawman proposal for a Certified JWT:</p>
<pre><code class="language-js">
{
  header: {
    &quot;alg&quot;: &quot;ES512&quot;,
    &quot;typ&quot;: &quot;JWT&quot;,
    /* new entry in header */
    &quot;certified-public-key&quot;: {
      &quot;value&quot;: &quot;MIIBIjANBgkqhkiG&quot;,
      &quot;signature&quot;:  ECDSASHA512(
          &quot;&lt;value&gt;&quot;,
          &quot;&lt;idp-private-key&gt;&quot;
      ),
    }
  },
  payload: {
    &quot;sub&quot;: &quot;1234567890&quot;,
    &quot;name&quot;: &quot;John Doe&quot;,
    &quot;admin&quot;: true,
    &quot;iat&quot;: 1516239022,
    /* new entry in payload */
    &quot;recovery&quot;: ECDSASHA512(&quot;&lt;user_id&gt;&quot;, RP, &quot;&lt;salt&gt;&quot;)
  },

  signature: ECDSASHA512(
    base64(header) + &quot;.&quot; + base64(payload),
    &quot;&lt;browser-private-key&gt;&quot;)
  }
}
</code></pre>
<h3>Recovery Flow</h3>
<p>Recovery code is an opaque value that can be computed given user id, RP site,
and a salt value e.g., <code>recovery code = SHA512(user_id, RP, salt)</code>.</p>
<p>The recovery code is kept at the RP. But it may be passed to the IDP to uniquely
identify the user. This means that an RP and IDP may be able to identify the
user if they directly or indirectly (e.g., browser mediation) collaborate. This
enables the recovery mechanism for a user to sign in to their existing account
on RP in a few important situations:</p>
<ol>
<li>A browser that implements WebID but does not have access to the original
certificate database (e.g., a fresh install). This mediated recovery
maintains IDP blindness.</li>
<li>A browser or agent (e.g., a mobile app) that does not implement WebID
protocol and OAuth flows are needed. Here the recovery code may be passed by
the RP to the IDP which can authenticate the user and generate a regular JWT
token. Notice that here <strong>IDP gets unblinded</strong> as it learns about the user
sign-in to the RP.</li>
</ol>
<p>A random salt ensures that neither RP nor IDP is able to unblind themselves
simply by enumerating all possible values.</p>
<figure>
  <img src="./static/delegation-api-recovery-signin-flow.svg" alt="Sign-In (Recovery) Flow for a fresh WebID enabled browser" />
  <figcaption>Sign-In (Recovery) Flow for a fresh WebID enabled browser</figcaption>
</figure>
<figure>
  <img src="./static/delegation-api-recovery-legacy-flow.svg" alt="Sign-In (Recovery) Flow for legacy non-WebID enabled browser/apps" />
  <figcaption>Sign-In (Recovery) Flow for legacy non-WebID enabled browser/apps</figcaption>
</figure>
